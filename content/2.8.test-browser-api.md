# How to Test Function Depending on a Browser API

In this lesson we'll see how to test functions depending on the Browser API-s.

//tags
browser
canvas
unit test
// end tags

While working on browser applications we often need to use APIs provided by the browser like `document.createElement`. How to go about testing such functions? Let's use a function that draws a square as an example.

## The function

Here's the breakdown of `src/draw-square.mjs` as seen in the next code playground:

- ```js
  export function drawSquare(element, width) {
  ```

  The line `export`-s the function for other modules to `import` and use. Expects a `element` and a `width` parameters.

- ```js
  const canvas = document.createElement('canvas');
  ```

  The line creates a [canvas HTML element](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API) `<canvas></canvas>` using the browser API.

  Note: it's not attached to the [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction) yet.

- ```js
  element.appendChild(canvas);
  ```

  The line attaches the canvas element to the DOM by appending it to the `element` that's passed as the function parameter.

- ```js
  const context = canvas.getContext('2d');
  ```

  The line calls the `getContext` method of the canvas, that will return the `context` object which in turn allows drawing shapes and lines in the canvas.

- ```js
  context.rect(0, 0, width, width);
  ```

  The line uses `rect` to draw a rectangle in the top-right corner of the canvas (0,0) using `width` as its width and height.

## Run it

Let's run the code below, look at the results and break down the test.

// code

## Breakdown

This spec is a bit more involved than what we're used to in the course so far. It resembles Ð° real-world function's test. Let's look at it line-by-line:

- ```js
  import { drawSquare } from '/__src__/draw-square.mjs';
  ```

  The line `import`-ing the `drawSquare` function from its module to use in the current module. The spec file is a module too - `.mjs`.

- ```js
  describe('drawSquare', () => {
    it('should create canvas, append it in the element, get a 2d context and draw the square', () => {
  ```

  This code uses `describe` to start a suite and `it` to start a test.

- ```js
  const contextMock = { rect: jasmine.createSpy('rect') };
  ```

  This line creates a `contextMock` that is an object with the method `rect`. It simulates the canvas's context method we use in the function - `context.rect(...)`.

- ```js
  const canvasMock = { getContext: jasmine.createSpy('canvasMock') };
  ```

  This line creates a `canvasMock`. This is an object that exposes a `getContext` method. It simulates the canvas element's method we use in the function - `canvas.getContext`.

- ```js
  canvasMock.getContext.and.returnValue(contextMock);
  ```

  This line instructs the `getContext` method to return the `contextMock` when called at line 9 of the `src/draw-square.mjs` file. We need that so that the context we use while testing the function is the one we prepared and can spy on its method calls


- ```js
  const documentSpy = spyOn(document, 'createElement').and.returnValue(canvasMock);
  ```

  here we apply a spy on the global `document` object. That will listen on the calls to the `createElement` method and will intercept them. `.and.returnValue` tells the spy what to return for any call to that method. In this case we return the prepared `canvasMock`.


- ```js
  const element = { appendChild: jasmine.createSpy('appendChild') };
  ```
  we prepare the input for the function-under-test and setup a mock object that has a `appendChild` method. It will be used at line 8 of `drawSquare`
  > At this point we've set up the test's environment and input to be controlled by us - all the methods used by the function-under-test: `document.createElement`, `canvas.getContext`, `context.rect`, and `element.appendChild` are now spied or mocked functions that
  >
  > - we can query for calls
  > - we can mock their results

- ```js
  drawSquare(element, 10);
  ```
  call the function to enact its effects and get ready to make the assertions

- ```js
  expect(documentSpy).toHaveBeenCalledTimes(1);
  ```
  first, we assert that the `document.createElement` spy has been called (`documentSpy`) exactly 1 time

- ```js
  expect(element.appendChild).toHaveBeenCalledOnceWith(canvasMock);
  ```
  next, we assert that the `appendChild` method from the input parameter `element` was called and the `canvasMock` was passed in as the parameter. This line asserts that the `canvas` is attached to the `element` as is the functions logic

- ```js
  expect(canvasMock.getContext).toHaveBeenCalledOnceWith('2d');
  ```
  this line asserts that the `getContext` method of the `context` was called as is the logic of the function

- ```js
  expect(contextMock.rect).toHaveBeenCalledOnceWith(0, 0, 10, 10);
  ```
  finally, asserting that the `rect` was called using the specific set of parameters `0,0` for the top left and `10,10` for the width and height of the rectangle - making it a square with side of 10px

## Spies and mocks

> We are using spies and mocks and they are basically the same with one difference:
>
> - spy is applied on an existing object's method `spyOn(document,`createElement')`
> - mock is an object of a function that we create from scratch and set up a spy on its method

## Logic is captured

Now, this test has captured the logic of the function so tightly that any change to the function will inevitably break the test and let us know immediately.

And in the end that is a major part of what the test is supposed to do. Make sure that what we've created stays as is.

## Exercise

Looking at the code playground below there is a `src/draw-circle.mjs` file with a function that is very similar to the `drawSquare` with the only difference that it calls `context.arc()` with

- the center of the circle (x,y - both being the `radius` so that the circle can be centered in the canvas)
- the radius is the third parameter and again `radius` is passed in
- the 0 and 360 are the beginning and end angles of the arc being drawn which is full circle

Go ahead and write a test for that in the `spec/draw-circle.mjs` file.

> Hint: a large portion of the test we broke down above can be used.

Keep in mind that we are using a different function from the `context` - the `arc` sp the context` mock should change as well as the assertion! See below the playground for more hints.

// code

// hint
// end hint
