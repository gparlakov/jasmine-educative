# Unit Testing Promise-s

\- Promise-s are used all over Javascript

\- let's see how they can be tested using `async` and `await`


In everyday work, we often need to deal with Promises ([MDN article](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)). Jasmine allows for a straightforward way of testing these using `async` and `await` ([MDN artcle](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function))

## The ArticleDelete class

What follows is a very simplified example of a class that handles deleting articles in a browser application. It will accept some input and make a request to a server API if conditions are met.

> For this lesson, the ArticleAPI methods are considered returning `Promise`-s. So the `delete` method returns a `Promise`.

The `ArticeDelete` class is relying on a `ArticleAPI` class to make a `DELETE /api/article/:id` call if conditions are met.

- `ArticleAPI` is a class that would implement the server API call. _It is empty as that's outside of the current lesson scope, and we'll be mocking its responses for the tests_
- `ArticleDlete` is the main class
  - ```js
    import { ArticleAPI } from './article-api.mjs';
    ```
    importing the ArticleAPI dependency from the adjacent module in the current folder `article-api.mjs`

  - ```js
    export class ArticleDelete {
    ```
    exporting the class to be used in other modules
  - ```js
      /** @type {ArticleAPI} */
      articleAPI;

      /**
       * @param { ArticleAPI } article the article api
       */
      constructor(articleApi) {
        this.articleAPI = articleApi;
      }
    ```
    declaring the `articleAPI` class instance property and populating it when an instance of the class gets constructed. In other words,  constructing an instance of the `ArticleDelete` class will require an instance of `ArticleAPI` class.
  - ```js
      async delete(a) {
        if (a != null && a.id != null) {
          try {
            await this.articleAPI.delete(a.id);
            return `article deleted: "${a.title}"`;
          } catch(e) {
            //... skipped
          }
        }

        return 'no article to delete';
      }
    ```
    calls the ArticleAPI `delete` method and `await`s its response then returns the positive result. The `try catch` block wraps this logic. So if the `delete` method returns a promise that gets rejected the `catch` will get invoked.
  - ```js
    catch (e) {
      if (e && e.status === 404) {
        return `It looks like article "${a.title}" has alreay been deleted`;
      }
      return `Unknown error trying to delete "${a.title}". Please try again.`;
    }
    ```
    the `catch` logic
      - when the response has a status of 404 (Not found) we'll inform the caller (of the method) that this article has already been deleted
      - otherwise infom the caller that there was an issue with deleting this article

## Test breakdown

Looking at the `spec/article-delete.spec.mjs` file we have:
 - ```js
   import { ArticleDelete } from '../__src__/article-delete.mjs';

   describe('ArticleDelete', () => {
   ```
   we start with `import`ing the `ArticleDelete` class and declaring a test suite for it `describe('ArticleDelete', () => {`
 - ```js
   let article;
   let articleAPI;

   beforeEach(() => {
     articleAPI = jasmine.createSpyObj('article API', ['delete']);
     article = new ArticleDelete(articleAPI);
   });
   ```
   knowing that we need an instance of the `ArticleAPI` we create a spy object with a spy on the `delete` method as that's the only method we use in the logic of the `ArticleDelete` class. Then in the next line, we instantiate an `ArticleDelete` instance. These two instances will get renewed `beforeEach` test so that each test executes in isolation from the others and no one test influences the others.

### Green path breakdown

In the test case `should call the articleAPI delete and return the deleted article title` we focus on the so called "green path" test aka "happy path" [wiki article](https://en.wikipedia.org/wiki/Happy_path). That is testing for the case that the method receives what it expects and works as intended.
- ```js
  it(`should call the articleAPI delete and return the deleted article title`, async () => {
  ```
  notice the second parameter of `it` is an async [function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function). Jasmine knows what to do with such functions. Essentially, this function returns a `Promise` and Jasmine waits for it to get resolved. And the function itself will wait for any `await ...` to get resolved too.
- ```js
  // arrange
  articleAPI.delete.and.returnValue(Promise.resolve({id: 1}));
  ```
  using the mocking capabilities we make sure that when `delete` method of the `ArticleAPI` gets called it returns a `Promise`. `Promise.resolve` returns a `Promise` that is resolved with the specified result - in this case `{id: 1}`.
- ```js
  // act
  const result = await article.delete({ id: 1, title: 'the first article' });
  ```
  then, we call the `delete` method and `await` its response to get resolved
- ```js
  // assert
  expect(articleAPI.delete).toHaveBeenCalledOnceWith(1);
  expect(result).toEqual('article deleted: "the first article"');
  });
  ```
  finally, we assert that the `delete` has been called and the `result` is as expected

### 404 error test breakdown

In the test case `when the articleAPI delete returns status 404 it should return - already been deleted` we'll make sure the behaviour of the `ArticleDelete.delete` method is as expected for the case that a `404 Not found` is returned from the server.

- ```js
  it(`when the articleAPI delete returns status 404 it should return - already been deleted`, async () => {
  ```
  notice the second parameter of `it` is an async [function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function), taking advantage of the Jasmine's Promise handling capability.
- ```js
  // arrange
  articleAPI.delete.and.returnValue(Promise.reject({status: 404, message: 'not found'}));
  ```
  using the mocking capabilities we make sure that when `delete` method of the `ArticleAPI` gets called it returns a `Promise`. `Promise.reject` returns a `Promise` that is rejected with the specified result - in this case `{status: 404, message: 'not found'}`.

  _Note: This is just an example of how a rejected Promise might look like ([axios](https://axios-http.com/docs/handling_errors)). Depending on the specific API or library used the rejection might not happen on a 404_
- ```js
  // act
  const result = await article.delete({ id: 1, title: 'the first article' });
  ```
  then, we call the `delete` method and `await` its response to get resolved
- ```js
  // assert
  expect(result).toEqual('It looks like article "the first article" has alreay been deleted');
  ```
  finally, we assert that the `delete` has been called and the `result` is as expected for the 404 case

## Exercise

For this exercise, we'll use the `src/article-create.mjs` in the code playground below. The `ArticleCreate` class is very similar to `ArticleDelete` with the difference being the `create` method:
- ```js
  create(title, content) {
    if (typeof title === 'string' && typeof content === 'string') {
      this.articleAPI.create(title, content);
      return `article created: "${title}" with content "${content}"`;
    }

    return `expected string title and content but recived title: "${title}" content: "${content}"`;
  }
  ```
  it takes 2 parameters: `title` and `content` to create the article. And it invokes the `ArticleAPI`'s `create` method. The returned strings confirm the creation of the article or inform of an error.

Let's create the 2 specs for the above logic
 - when called with a title and content it invokes the `ArticleAPI`'s method `create`
 - when called without a title or content, it returns an error explanation.
